DSA Algorithms 
 
1). Merge Sort 
def merge_sort(list1,low,high): 
    if low>=high: 
        return 
    mid=(low+high)//2 
    merge_sort(list1,low,mid) 
    merge_sort(list1,mid+1,high) 
    merge(list1,low,high,mid) 
 
def merge(list1,low,high,mid): 
    sublist1=list1[low:mid+1] 
    sublist2=list1[mid+1:high+1] 
    k=0 
    m=0 
    s=low 
    while(k<len(sublist1) and m<len(sublist2)): 
        if sublist1[k]<=sublist2[m]: 
            list1[s]=sublist1[k] 
            k=k+1 
        else: 
            list1[s]=sublist2[m] 
            m=m+1 
        s=s+1 
         
    while k<len(sublist1): 
        list1[s]=sublist1[k] 
        k=k+1 
        s=s+1 
             
 
 
    while m<len(sublist2): 
        list1[s]=sublist2[m] 
        m=m+1 
        s=s+1 
        
#calling code 
list1=[12,9,15,34,45,-3,65,7,84,55] 
print("List before sorting: ", list1) 
merge_sort(list1,0,len(list1)-1) 
print("List after sorting: ", list1) 
 
 
2). Quick Sort 
def partition(array, low, high): 
    pivot = array[low] 
    i = low + 1 
    j = high 
 
    while True: 
        while i <= j and array[i] <= pivot: 
            i = i + 1 
        while j >= i and array[j] >= pivot: 
            j = j - 1 
 
        if i < j: 
            array[i], array[j] = array[j], array[i] 
        else: 
            break 
    array[low], array[j] = array[j], array[low] 
    return j 
 
 
 
# The main function that implements QuickSort 
def quick_sort(array, i, j): 
    if i < j: 
        id = partition(array, i, j) 
        quick_sort(array, i, id-1) 
        quick_sort(array, id+1, j) 
 
# Function to print an array 
def print_arr(arr, n): 
    for i in range(n): 
        print(arr[i], end=" ") 
    print() 
 
# Driver Code 
arr1 = [17, 60, 10, 5, 9, 21, 1, 15, 7] 
quick_sort(arr1, 0, len(arr1)-1) 
print_arr(arr1, len(arr1)) 
 
3). Binary Search 
def binary_search(arr, x): 
 low = 0 
 high = len(arr) - 1 
 mid = 0 
 
 while low <= high: 
 
  mid = (high + low) // 2 
 
  # If x is greater, ignore left half 
  if arr[mid] < x: 
   low = mid + 1 
 
  # If x is smaller, ignore right half 
elif arr[mid] > x: 
high = mid - 1 
# means x is present at mid 
else: 
return mid 
# If we reach here, then the element was not present 
return -1 
# Test array 
arr = [ 2, 3, 4, 10, 40 ] 
x = 10 
# Function call 
result = binary_search(arr, x) 
if result != -1: 
print("Element is present at index", str(result)) 
else: 
print("Element is not present in array") 
4). Print Pascal's Triangle in Python 
# input n 
n = 5 
spaces=5 
for i in range(1, n+1): 
    for j in range(0, spaces): 
        print(' ', end='') 
 
    # first element is always 1 
    C = 1 
    for j in range(1, i+1): 
 
        # first value in a line is always 1 
        print(' ', C, sep='', end='') 
 
        # using Binomial Coefficient 
        C = C * (i - j) // j 
    spaces-=1 
    print() 
 
5). Recursive Python function to solve the tower of Hanoi 
 
def TowerOfHanoi(n , A, B, C): 
    if n==1: 
        print ("Move disk 1 from source",A,"to destination",C) 
        return 
    TowerOfHanoi(n-1, A, C, B) 
    TowerOfHanoi(1, A, B, C) 
    TowerOfHanoi(n-1, B, A, C) 
         
# Driver code 
n = 3 
TowerOfHanoi(n,'A','B','C') 